/**
<h1>Tree, automatic table of contents and other tools for clickable trees</h1>


LGPL http://www.gnu.org/licenses/lgpl.html
© 2005 Frederic.Glorieux@fictif.org et École nationale des chartes
© 2012 Frederic.Glorieux@fictif.org
© 2013 Frederic.Glorieux@fictif.org et LABEX OBVIL


<p>
Manage show/hide trees. No dependancies to a javascript library.
The HTML structure handled is a multilevel list with nested ul in li.
Relies the more as possible on CSS, and toggles between
classes, especially to display groups of items (ul).
<b>li.plus</b> means there is more items inside (ul inside are hidden).
<b>li.minus</b> means it's possible to hide items inside.
First usecase is to generate an autotoc on the header hierarchy of HTML page.
All the events on such trees are also available for user written table of contents.
The method Tree.load() (to use on an body.onload() event) may be used to to add events
to all li.plus and li.minus.
</p>

<pre>
<body>

  <h1>Title of page</h1>
  ...
  <h2 id="header_id">1) header</h2>
  ...
  <h2>2) header</h2>
  ...

  <div id="nav ">
    <-- Generated by javascript -->
    <ul class="tree">
      <li class="plus"><a href="#h_1">Title of page</a>
        <ul>
          <li><a href="#header_id">1) header</a></li>
          <li><a href="#h_3">2) header</a></li>
        </ul>
      </li>
    </ul>
  </div>
  <!-- all li.plus and li.minus will become clickable -->
  <script src="../teipot/js/Tree.js">//</script>
</pre>



 */
if (!document.createElementNS) document.createElementNS = function (uri, name) {
    return document.createElement(name);
};



var Tree = {

    /** default class name for root ul */
    TREE: "tree",
    /** default class name for li with hidden list */
    MORE: "more",
    /** default class name for li with visible list */
    LESS: "less",
    /** default class name for clicked link */
    HERE: "here",
    /** default class name of  */
    ASIDE: "sidebar",
    /** the pannel element */
    aside: null,
    /** default id where to find titles */
    MAIN: "main",
    /** the main element */
    main: null,
    /** default id where to put an autotoc */
    TOC: "toc",

    /**
     * Ititialisation of the object
     */
    ini: function () {
        if (Tree.reLessmore) return;
        Tree.reLessmore = new RegExp(" *(" + Tree.LESS + "|" + Tree.MORE + ") *", "gi");
        Tree.reHere = new RegExp(" *(" + Tree.HERE + ") *", "gi");
        // case seems sometimes significant
        Tree.reHereDel = new RegExp(' *' + Tree.HERE + ' *', "gi");
    },

    /**
     * What can be done for document.onload
     */
    loaded: false,
    load: function () {
        const els = document.getElementsByClassName(Tree.TREE);
        for (var maxj = els.length, j = 0; j < maxj; j++) {
            Tree.treeprep(els[j]);
        }
    },

    /**
     * Add events to a a recursive list
     */
    treeprep: function (ul) {
        if (!ul) return false;
        if (ul.nodeType != 1) ul = document.getElementById(ul);
        if (!ul) return false;
        if (ul.className.indexOf("tree") == -1) return false;
        var nodeset = ul.getElementsByTagName("li");
        for (var i = 0; i < nodeset.length; i++) {
            target = "";
            li = nodeset[i];
            // if item as children, hide them
            if (li.getElementsByTagName("ul").length && li.className.search(Tree.reLessmore) == -1) {
                li.className = Tree.MORE + " " + li.className;
            }
            li.ul = ul; // set the root ul
            // note capture=false, to allow links target
            li.addEventListener('click', Tree.click, false);
            // hilite current link in this item
            var links = li.getElementsByTagName("a");
            if (!links.length) continue;
            // this loop will go inside all links of the <li>, especially children <ul>, bad
            // for(var j=0; j < links.length; j++) {
            a = links[0];
            // build 

            parent = a;
            // for a folder with no link, do not hilite here
            while (parent = parent.parentNode) {
                if (parent.nodeName.toLowerCase() != 'li') continue;
                if (parent == li) break;
                a = null;
            }
            if (!a) continue;
            // now, check if item should be opened

            target = a.getAttribute('href'); // should return unresolved URI like written in source file
            if (location.pathname != a.pathname) continue; // not same path, go away
            keep = true; // at least, correct path, but check if hash or query could be better
            if (Tree.lastHere && a.hash && !location.hash) continue; // hash requested, no hash in URI, let first item found
            if (Tree.lastHere && a.hash && a.hash != location.hash) continue; // hash requested, not good hash in URI, let first item found
            if (Tree.lastHere && a.search && !location.search) continue; // query param requested, no query parma in URI, let first item found
            if (a.search && location.search) {
                search = a.search.replace('?', '&') + '&';
                lost = location.search.replace('?', '&') + '&';
                found = lost.indexOf(search);
                if (Tree.lastHere && found < 0) continue; // query param not found, let first item found
            }
            /*
            // class on li or a ?
            if (a.className.indexOf(Tree.HERE) != -1) a.className=a.className.replace(Tree.reHereDel, '');
            a.className += " "+Tree.HERE;
            */
            // close parents of first found
            if (Tree.lastHere) {
                Tree.lastHere.className = Tree.lastHere.className.replace(Tree.reHereDel, '');
                Tree.close(Tree.lastHere);
            }
            // open parents
            Tree.open(li);
            li.className = li.className.replace(Tree.reHereDel, '') + " " + Tree.HERE;
            if (li.focus) li.focus();
            Tree.lastHere = li;
        }
        // add a class for CSS to say this list is set (before display none things)
        if (ul.className.indexOf("treejs") != -1);
        else { ul.className = ul.className + " treejs"; }
        // changing global class should have resized object
        // check if link is visible, if not, scroll to it
        /*
        if (Tree.top(Tree.lastHere) > Tree.winHeight()) {
          lastid = window.location.hash;
          if (lastid == '#') lastid=null;
          Tree.lastHere.id = "lasthere";
          window.location.hash = '#' + Tree.lastHere.id;
          window.location.hash = lastid;
        }
        */
    },

        /**
     * For event.target, get first element of name
     * @param {*} el 
     * @param {*} name 
     * @returns 
     */
    selfOrAncestor: function(el, name) {
        if (!el) return false;
        if (!el.tagName) return false;
        while (el.tagName.toLowerCase() != name) {
            el = el.parentNode;
            if (!el) return false;
            let tag = el.tagName.toLowerCase();
            if (tag == 'div' || tag == 'nav' || tag == 'body') return false;
        }
        return el;
    },

    /**
     * Change ClassName of a <li> onclick to open/close
     */
    click: function (event, close=null) {
        // do not propagate event to parents
        if (event && event.stopPropagation) event.stopPropagation();
        // open or close ?
        src = event.target;
        // Click in a link ? force open
        const a = Tree.selfOrAncestor(event.target, 'a');
        // click in a link force open
        if (a) { // propagate
            close = false;
        }
        let li = Tree.selfOrAncestor(event.target, 'li');
        if (!li) {
            // ???
            console.log("Not LI ?");
            return;
        }
        // unhilight last
        if (Tree.lastHere) {
            Tree.lastHere.classList.remove(Tree.HERE);
        }
        Tree.lastHere = li;
        li.classList.add(Tree.HERE);
        if (close === null) {
            close = li.classList.contains(Tree.LESS);
        }
        if (close) {
            // be careful of leaf without children
            if (li.classList.contains(Tree.LESS)) {
                li.classList.remove(Tree.LESS);
                li.classList.add(Tree.MORE);
            }
        }
        else  {
            // recursive open
            do {
                if (li.classList.contains(Tree.MORE)) {
                    li.classList.remove(Tree.MORE);
                    li.classList.add(Tree.LESS);
                }
                li = Tree.selfOrAncestor(li.parentNode, 'li');
            } while (li);
        }
    },
    /**
     * Recursively open li ancestors
     */
    open: function () {
        let li; // don't forget or may produce some strange var collapse
        for (i = arguments.length - 1; i >= 0; i--) {
            li = arguments[i];
            if (li.className == null) li = document.getElementById(arguments[i]);
            if (!li) continue;
            while (li && li.tagName.toLowerCase() == 'li') {
                // avoid icon in front of single item
                if (li.className.match(Tree.reLessmore) || li.getElementsByTagName('UL').length > 0)
                    li.className = (li.className.replace(Tree.reLessmore, ' ') + " " + Tree.LESS).trim();
                li = li.parentNode.parentNode; // get a possible li ancestor (jump an ul container)
            }
        }
    },
    /**
     * Recursively close li ancestors
     */
    close: function () {
        var li; // don't forget or may produce some strange var collapse
        for (i = arguments.length - 1; i >= 0; i--) {
            li = arguments[i];
            if (li.className == null) li = document.getElementById(arguments[i]);
            if (!li) continue;
            while (li && li.tagName.toLowerCase() == 'li') {
                if (li.className.match(Tree.reLessmore) || li.getElementsByTagName('UL').length > 0)
                    li.className = (li.className.replace(Tree.reLessmore, ' ') + " " + Tree.MORE).trim();
                li = li.parentNode.parentNode; // get a possible li ancestor (jump an ul container)
            }
        }
    },
    /**
     * Hilite an anchor element, now replaced by the :target CSS selector
     */
    hash: function (id) {
        // id maybe an Event
        if (id && id.stopPropagation) id = null;
        // if another element has been hilited
        if (!this.window.anchorLast);
        else {
            this.window.anchorLast.className = this.window.anchorLast.className.replace(/ *mark */g, '');
        }
        if (!id) {
            id = window.location.hash;
            if (id.indexOf('#') != 0) return false;
            id = id.substring(1);
        }
        var o = document.getElementById(id);
        // if (!o) take from anchors array ?
        if (!o) return false;
        if (o.className.indexOf("mark") > -1) return false;
        o.className += " mark";
        this.window.anchorLast = o;
        // here it's OK, but an event scroll the page to its right place after
        return false;
    }

    /**
     * Snchronyze scroll with toc
     */
    /*
    scroll: function() {
        var up = false;
        var scrollY = window.pageYOffset || document.documentElement.scrollTop;
        if (scrollY < Liser.lastScrollY) up = true;
        Liser.lastScrollY = (scrollY <= 0) ? 0 : scrollY; // phone scroll could be negative


        // les premières notes sont elles en vue ?
        var id = Liser.noterefs[0].hash;
        if (id[0] == '#') id = id.substring(1);
        var note = document.getElementById(id);
        if (Liser.isVisible(note)) {
            Liser.notebox.innerHTML = "";
            Liser.notebox.style.visibility = "hidden";
            return;
        }
        var count = 0;
        for (var i = 0, len = Liser.noterefs.length; i < len; i++) {
            var ref = Liser.noterefs[i];
            var id = ref.hash;
            if (id[0] == '#') id = id.substring(1);
            var idCopy = id + "Copy";
            var noteCopy = document.getElementById(idCopy);
            if (Liser.isVisible(ref)) {

                count++;
                if (noteCopy) continue; // déjà affichée
                var note = document.getElementById(id);
                if (!note) continue; // no note ? bad
                noteCopy = note.cloneNode(true);
                noteCopy.id = idCopy;
                if (up) Liser.notebox.insertBefore(noteCopy, Liser.notebox.firstChild); // prepend not for MS
                else Liser.notebox.appendChild(noteCopy);
            } else {
                if (!noteCopy) continue;
                noteCopy.parentNode.removeChild(noteCopy);
            }
        }
        if (!count) Liser.notebox.style.visibility = "hidden";
        else Liser.notebox.style.visibility = "visible";
    }
    */

}



Tree.ini();

// if loaded as bottom script, create trees ?
if (window.document.body) {
    Tree.load();
} else if (window.addEventListener) {
    window.addEventListener('load', Tree.load, false);
}

(function() {
    const treeBack = function(event) {
        const a = Tree.selfOrAncestor(event.target, 'a');
        let hash = a.hash;
        if (!hash) return;
        if (hash.startsWith('#')) hash = hash.substring(1);
        if (!hash.startsWith('tree_')) return;


        const target = document.getElementById(hash);
        const li = Tree.selfOrAncestor(target, 'li');
        if (!li) return;

        event.preventDefault();
        // rewrite the hash
        let div = a.parentNode;
        while (!div.id) {
            div = div.parentNode;
            if (!div) break;
        }
        if (div && div.id) {
            if (history.replaceState) {
                history.replaceState(null, null, '#' + div.id);
            }
        }
        li.click(event, false);
        li.scrollIntoView({ behavior: "smooth", block: "center", inline: "nearest" });
    };

    const titles = document.querySelectorAll(".tree_back");
    titles.forEach(function(el) {
        el.addEventListener('click', treeBack, true);
    });

}());
